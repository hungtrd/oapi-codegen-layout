package handlers

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	openapi_types "github.com/oapi-codegen/runtime/types"
	"gorm.io/gorm"
	"oapi-codegen-layout/internal/models"
	apimodels "oapi-codegen-layout/pkg/api/models"
	"oapi-codegen-layout/pkg/api/products"
)

// ProductHandler implements the products.ServerInterface generated by oapi-codegen
type ProductHandler struct {
	db *gorm.DB
}

// NewProductHandler creates a new product handler
func NewProductHandler(db *gorm.DB) *ProductHandler {
	return &ProductHandler{
		db: db,
	}
}

// Ensure ProductHandler implements products.ServerInterface
var _ products.ServerInterface = (*ProductHandler)(nil)

// ListProducts returns a list of products
// (GET /products)
func (h *ProductHandler) ListProducts(c *gin.Context, params products.ListProductsParams) {
	var dbProducts []models.Product

	query := h.db

	// Apply category filter if provided
	if params.Category != nil && *params.Category != "" {
		query = query.Where("category = ?", *params.Category)
	}

	// Apply limit if provided
	if params.Limit != nil {
		query = query.Limit(int(*params.Limit))
	}

	if err := query.Find(&dbProducts).Error; err != nil {
		c.JSON(http.StatusInternalServerError, apimodels.Error{
			Code:    "database_error",
			Message: "Failed to retrieve products",
		})
		return
	}

	// Convert database products to API products
	apiProducts := make([]apimodels.Product, len(dbProducts))
	for i, dbProduct := range dbProducts {
		apiProducts[i] = dbProductToAPIProduct(&dbProduct)
	}

	c.JSON(http.StatusOK, apiProducts)
}

// CreateProduct creates a new product
// (POST /products)
func (h *ProductHandler) CreateProduct(c *gin.Context) {
	var req apimodels.CreateProductRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, apimodels.Error{
			Code:    "invalid_request",
			Message: err.Error(),
		})
		return
	}

	// Convert API request to database model
	dbProduct := apiCreateProductToDBProduct(&req)

	// Create product in database
	if err := h.db.Create(dbProduct).Error; err != nil {
		c.JSON(http.StatusInternalServerError, apimodels.Error{
			Code:    "database_error",
			Message: "Failed to create product",
		})
		return
	}

	// Convert database model to API model
	product := dbProductToAPIProduct(dbProduct)

	c.JSON(http.StatusCreated, product)
}

// GetProductById retrieves a product by ID
// (GET /products/{productId})
func (h *ProductHandler) GetProductById(c *gin.Context, productId openapi_types.UUID) {
	var dbProduct models.Product

	// Query product by ID
	if err := h.db.Where("id = ?", uuid.UUID(productId)).First(&dbProduct).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, apimodels.Error{
				Code:    "not_found",
				Message: "Product not found",
			})
		} else {
			c.JSON(http.StatusInternalServerError, apimodels.Error{
				Code:    "database_error",
				Message: "Failed to retrieve product",
			})
		}
		return
	}

	// Convert database model to API model
	product := dbProductToAPIProduct(&dbProduct)

	c.JSON(http.StatusOK, product)
}

// UpdateProduct updates an existing product
// (PUT /products/{productId})
func (h *ProductHandler) UpdateProduct(c *gin.Context, productId openapi_types.UUID) {
	var req apimodels.UpdateProductRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, apimodels.Error{
			Code:    "invalid_request",
			Message: err.Error(),
		})
		return
	}

	var dbProduct models.Product

	// Query product by ID
	if err := h.db.Where("id = ?", uuid.UUID(productId)).First(&dbProduct).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, apimodels.Error{
				Code:    "not_found",
				Message: "Product not found",
			})
		} else {
			c.JSON(http.StatusInternalServerError, apimodels.Error{
				Code:    "database_error",
				Message: "Failed to retrieve product",
			})
		}
		return
	}

	// Update fields if provided
	if req.Name != nil {
		dbProduct.Name = *req.Name
	}
	if req.Description != nil {
		dbProduct.Description = req.Description
	}
	if req.Price != nil {
		dbProduct.Price = *req.Price
	}
	if req.Category != nil {
		dbProduct.Category = *req.Category
	}
	if req.Stock != nil {
		dbProduct.Stock = *req.Stock
	}

	// Save updated product
	if err := h.db.Save(&dbProduct).Error; err != nil {
		c.JSON(http.StatusInternalServerError, apimodels.Error{
			Code:    "database_error",
			Message: "Failed to update product",
		})
		return
	}

	// Convert database model to API model
	product := dbProductToAPIProduct(&dbProduct)

	c.JSON(http.StatusOK, product)
}

// DeleteProduct deletes a product
// (DELETE /products/{productId})
func (h *ProductHandler) DeleteProduct(c *gin.Context, productId openapi_types.UUID) {
	var dbProduct models.Product

	// Query product by ID
	if err := h.db.Where("id = ?", uuid.UUID(productId)).First(&dbProduct).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, apimodels.Error{
				Code:    "not_found",
				Message: "Product not found",
			})
		} else {
			c.JSON(http.StatusInternalServerError, apimodels.Error{
				Code:    "database_error",
				Message: "Failed to retrieve product",
			})
		}
		return
	}

	// Delete product (soft delete by default with GORM)
	if err := h.db.Delete(&dbProduct).Error; err != nil {
		c.JSON(http.StatusInternalServerError, apimodels.Error{
			Code:    "database_error",
			Message: "Failed to delete product",
		})
		return
	}

	c.Status(http.StatusNoContent)
}

// Helper functions
func strPtr(s string) *string {
	return &s
}

func int32Ptr(i int32) *int32 {
	return &i
}

func timePtr(t time.Time) *time.Time {
	return &t
}

func getOrDefault(ptr *string, def string) string {
	if ptr != nil {
		return *ptr
	}
	return def
}

func getOrDefaultFloat(ptr *float64, def float64) float64 {
	if ptr != nil {
		return *ptr
	}
	return def
}

// Helper functions to convert between database models and API models
func dbProductToAPIProduct(dbProduct *models.Product) apimodels.Product {
	return apimodels.Product{
		Id:          openapi_types.UUID(dbProduct.ID),
		Name:        dbProduct.Name,
		Description: dbProduct.Description,
		Price:       dbProduct.Price,
		Category:    dbProduct.Category,
		Stock:       &dbProduct.Stock,
		CreatedAt:   dbProduct.CreatedAt,
		UpdatedAt:   &dbProduct.UpdatedAt,
	}
}

func apiCreateProductToDBProduct(req *apimodels.CreateProductRequest) *models.Product {
	product := &models.Product{
		Name:     req.Name,
		Price:    req.Price,
		Category: req.Category,
	}
	if req.Description != nil {
		product.Description = req.Description
	}
	if req.Stock != nil {
		product.Stock = *req.Stock
	}
	return product
}
